---
title: "Inclass Interactive Plotting"
author: "Dwi Gustin Nurdialit"
date: "`r format(Sys.Date(), '%B %e, %Y')`"
output:
  html_document:
    theme: cosmo
    highlight: breezedark
    toc: true
    toc_float:
      collapsed: false
    df_print: paged
---

```{r setup, include=FALSE}
# clear-up the environment
rm(list = ls())

# chunk options
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  fig.align = "center",
  comment = "#>"
)

options(scipen = 100)
```


# Course Map

```{r echo=FALSE, out.width="100%"}
knitr::include_graphics("assets/Interactive Plotting.png")
```


# Introduction

Pada eksplorasi kali ini, akan digunakan satu package bernama [tidyverse](https://www.tidyverse.org/), yang mengusung konsep tidy dalam transformasi data. Adapun di dalam `tidyverse`, terdapat package-package yang umum digunakan untuk transformasi data, yakni `ggplot2`, `dplyr`, `tidyr`, `readr`, `purrr`, `tibble`, `stringr`, dan `forcats`.

```{r}
library(tidyverse)
library(ggpubr)
library(scales)
library(glue)
library(plotly)
library(lubridate)
```

#ï¸ Data Transformation using `dplyr`

```{r}
# install.packages("dplyr")
library(dplyr)
```

**ğŸ•µ `dplyr`** adalah package khusus yang mempermudah kita dalam melakukan data wrangling/cleaning/transformation. Tahapan data wrangling yang umum:

- cek data
- seleksi kolom
- filter baris
- membuat/mengubah kolom
- agregasi data
- mengurutkan data

- fungsi --> nama_fungsi()

## Load Data

Kita akan coba mengeksplorasi kembali data **Youtube Trending 2017, All Unique Videos** menggunakan package dplyr! Mari kita baca terlebih dahulu data kita:

```{r}
vids <- read.csv("data_input/youtubetrends.csv", stringsAsFactors = T)
```

## ğŸ›  `glimpse`: cek data

```{r eval=FALSE}
# base
str(vids)
```

```{r}
# dplyr
glimpse(vids)
```
Informasi: jumlah baris - kolom, nama kolom, tipe data, isi kolom

Deskripsi kolom: 

* **trending_date**: tanggal trending
* **title**: judul video
* **channel_title**: nama channel Youtube
* **category_id**: kategori video
* **publish_time**: tanggal upload video
* **views**: jumlah views
* **likes**: jumlah likes
* **dislikes**: jumlah dislikes
* **comment_count**: jumlah komentar
* **comment_disabled**: apakah kolom komentar tidak diaktifkan
* **ratings_disabled**: apakah rating video tidak diaktifkan
* **video_error_or_removed**: apakah video dihapus
* **publish_hour**: jam publish
* **publish_when**: periode waktu publish
* **publish_wday**: hari publish
* **timetotrend**: hari yang dibutuhkan untuk trending

## ğŸ›  `select`: seleksi kolom

â“Misalkan kita ingin mengambil kolom `trending_date` & `title`:


```{r eval=FALSE}
# base
vids_select1 <- vids[ , c("trending_date", "title")]
```

**dplyr: `select(data, kolom yg ingin diambil/dibuang)`**

```{r}
# dplyr
vids_select1 <- select(.data = vids, trending_date, title)
```

â“Misalkan kita ingin buang kolom `comments_disabled`, `ratings_disabled`, dan `video_error_or_removed` karena tidak digunakan:

```{r eval=FALSE}
# base: harus menggunakan index
vids_select2 <- vids[,-c(10,11,12)]
```

```{r}
# dplyr
select(.data = vids, -comments_disabled, -ratings_disabled, -video_error_or_removed)
```

## ğŸ›  `filter`: filter baris

Misalkan kita ingin mengambil video dari kategori *"Gaming"* dan memiliki views lebih dari 1 juta.


```{r eval=FALSE}
# base
vids_filter <- vids[vids$category_id == "Gaming" & vids$views > 1000000,]
```

```{r}
# dplyr
filter(.data = vids, 
       category_id == "Gaming",
       views > 1000000)
```

Notes: tanda koma (,) pada fungsi filter sama dengan operator &




## ğŸ›  `mutate`: memodifikasi kolom: ubah tipe data, menambah kolom baru, mengganti informasi suatu.

```{r eval=FALSE}
# base: mengubah tipe data kolom `title`
vids$title <- as.character(vids$title)
```

**dplyr::`mutate(data, nama kolom = isi kolom)`**

```{r}
glimpse(vids)
```


```{r}
# dplyr
mutate(.data = vids, 
       title = as.character(title))
```

Mengubah kolom channel title dan title menjadi character:

```{r}
# Pak Christoper
mutate(.data = vids, 
       title = as.character(title),
       channel_title = as.character(channel_title))
```

## Piping `%>%`

filter: menyeleksi baris
select: enyeleksi kolom
mutate: memanipulasi kolom

Piping `%>%` digunakan untuk menyambungkan proses yang **sequential** atau berurutan. Untuk lebih memahaminya, mari menuliskan kegiatan pagi kita dari bangun tidur hingga siap bekerja menggunakan piping:

**Shortcut Piping**: ctrl + shift + m / cmd + shift + m

Piping membuat penggabungan tahapan wrangling di atas menjadi lebih mudah:

â“Contoh: 

1. Buang kolom `comments_disabled`, `ratings_disabled`, dan `video_error_or_removed` --> select
2. Ambil video dari kategori "Gaming" yang memiliki views lebih dari 1 juta. --> filter

```{r eval=F}
# base
vids_temp <- vids[,-c(10,11,12)]
vids_music <- vids_temp[vids_temp$category_id == "Gaming" & vids_temp$views > 1000000,]

head(vids_music)
```

```{r}
# dplyr
vids_gaming <- vids %>% 
  select(-comments_disabled, -ratings_disabled, -video_error_or_removed) %>% 
  filter(category_id == "Gaming", views > 1000000)
```


bahan %>% memotong bahan %>% memcuci bahan %>% menghaluskan bahan 

```{r}
vids %>% 
  filter(category_id == "Gaming", views > 1000000) %>% 
  select(-comments_disabled, -ratings_disabled, -video_error_or_removed, -category_id)
```

```{r}
colSums(is.na(vids))
```

```{r}
vids %>% is.na() %>% colSums()
```


## ğŸ„ï¸ Dive Deeper!

Misal untuk kebutuhan analisis lanjutan kita akan mempersiapkan data terlebih dahulu. Kita ingin menganalisis **video** dan **channel youtube** yang trending dan mencari tahu **durasi yang mereka butuhkan hingga trending**. Analisis hanya untuk kategori **Music** (category_id) saja. 

- Kolom apa saja yang dipakai: title, channel_title, timetotrend 
- perlu difilter atau tidak?

```{r}
vids %>% head()
```


Sajikan data yang dibutuhkan:

```{r}
# code here
vids %>% 
  filter(category_id == "Music") %>% 
  select(title, channel_title, timetotrend)
```

## Data Cleansing

- Sebagai tahapan data wrangling di awal, kita akan buang kolom `comments_disabled`, `ratings_disabled`, dan `video_error_or_removed` karena tidak digunakan.

- Kemudian **memperbaiki tipe data** pada kolom:

  + trending_date, publish_time -> date & datetime (POSIXct)
  + title, channel_title -> character

- Kemudian coba **buat kolom** baru berupa:

  - buat kolom likesp (likes per view)
  - buat kolom dislikesp (dislikes per view)
  - buat kolom commentp (comment per view)

Kemudian simpan ke nama objek `vids_clean`:

> Tips: ketika melakukan cleansing data sebaiknya data disimpan dengan object yang berbeda.

```{r}
vids_clean <- vids %>% 
  # deselect kolom
  select(-c(comments_disabled, ratings_disabled, video_error_or_removed)) %>% 
  mutate(
    # mengubah tipe data
    trending_date = ymd(trending_date),
    publish_time = ymd_hms(publish_time),
    title = as.character(title),
    channel_title = as.character(channel_title),
    
    # menambahkan kolom baru
    likesp = likes/views,
    dislikep = dislikes/views,
    commentp = comment_count/views
  )

head(vids_clean)
```

Notes: fungsi mutate dapat digunakan untuk memanipulasi kolom seperti

  - Mengubah tipe data
  - Menambah kolom baru
  - Mengganti informasi suatu kolom

### Check missing value:


```{r}
# base R
colSums(is.na(vids_clean))
```

```{r}
# dplyr
vids_clean %>% is.na() %>% colSums()
```

---

## ğŸ›  Agregasi Data

Pada dplyr, kita dapat melakukan aggregasi data menggunakan `group_by()` dan `summarise()`, kemudian disempurnakan dengan fungsi penutup `ungroup()`.

- ğŸ›  `group_by()`: melakukan pengelompokkan berdasarkan kolom tertentu, sehingga proses apapun setelahnya dilakukan berdasarkan pengelompokkan tersebut.
- ğŸ›  `summarise()`: menghitung nilai statistik tertentu
- ğŸ›  `ungroup()`: melepaskan pengelompokkan agar proses apapun setelahnya dilakukan untuk keseluruhan data.

[Ilustrasi](https://docs.google.com/presentation/d/1GIQ4vkAiwAeVVRzVX3HDFw-R61pVQ4cqEE0hgVn117A/edit#slide=id.g10f92d5049a_0_165)

â“Coba hitung **rata-rata viewer** video trending yang dimiliki oleh **tiap channel youtube**:

```{r eval=FALSE}
# base
vids_agg <- aggregate(views ~ channel_title, data = vids_clean, FUN = mean)
```

```{r}
# dplyr
vids_clean %>% 
  group_by(channel_title) %>% 
  summarise(mean_viewers = mean(views)) %>% 
  ungroup()
```

- coba untuk mengaggregasi rata-rata dan total (sum) views untuk setiap channel_title

```{r}
# Bu Namira
vids_clean %>% group_by(channel_title) %>% 
  summarise(mean_viewers = mean(views), 
            total_viewers = sum(views),
            total_comment = sum(comment_count)) %>% 
  ungroup()
```

ğŸ“Œ Note: penggunaan `ungroup()` memang seringkali tidak terlihat efeknya, namun best practice setelah melakukan tahapan yang menggunakan grouping adalah melepas grouping tersebut menggunakan ungroup. Berikut contohnya mengapa ungroup diperlukan.

â“ Contoh kasus ingin melakukan aggregate untuk mencari rata-rata view sberdasarkan channel_title dan title, kemudian temukan nilai rata-rata paling besar dengan menggunakan fungsi `top_n()`

```{r}
# code here
vids_clean %>% 
  group_by(channel_title, title) %>% 
  summarise(mean_views = mean(views)) %>% 
  ungroup() %>% 
  top_n(1)
```

â“ Periode (hari dan jam) kapan seorang youtuber dapat mengupload videonya supaya memiliki views yang banyak (berdasarkan rata-rata)? Hanya untuk category **music**

Kolom yang digunakan: publish_when, publish_wday, category_id
Urutan piping: filter --> aggregate
  - filter hanya untuk music
  - groupby (publish_when, publish_wday), summarise (views), ungroup


```{r}
vids_agg <- vids_clean %>% 
  filter(category_id=="Music") %>% 
  group_by(publish_when, publish_wday) %>% 
  summarise(average = mean(views)) %>% 
  ungroup()
```

Hati-hati ketika membuatuhkan filter dan aggregasi secara bersamaan. Perlu dilakukan filter terlebih dahulu.

- filter: mangambil kolom
- groupby: mengelompokkan kolom berdasarkan nilai unique pada kolom tersebut

## ğŸ›  `arrange`: mengurutkan data 

Urutkan channel youtube dengan rata-rata viewer tertinggi hingga terendah dari kategori Music:

```{r eval=FALSE}
# base
vids_agg[order(vids_agg$average, decreasing = T),]
```


```{r}
# dplyr
vids_agg %>% 
  arrange(-average)
```

## ğŸ„ï¸ Dive Deeper!(sampai dengan 15.52)

1. Dwi ingin membuat suatu channel youtube namun masih bingung kategori video yang cocok dibuat. Sajikan suatu data lalu buatlah analisis dari setiap **kategori video** ada berapa jumlah video yang trending? Data yang didapat silahkan disimpan pada objek bernama `vids_count`. Berikan rekomendasi kategori video apa yang bisa Dwi buat supaya bisa trending.

hint: lakukan aggregasi berdasarkan frekuensi data `n()`

```{r}
# Code here
vids_count <- vids_clean %>% 
  group_by(category_id) %>% 
  summarise(count= n()) %>% 
  ungroup() %>% 
  arrange(-count)

vids_count
```

> ğŸ“ˆ Insight: Entertainment

2. Berdasarkan kategori video yang sudah direkomendasikan diatas, Dwi ingin menganalisis lebih lanjut channel mana yang memiliki jumlah rata-rata viewers tertinggi? Data yang didapat silahkan disimpan pada objek bernama `vids_10`. Ia ingin melihat 10 channel teratas sebagai referensi channel yang akan dibuat. Channel apa saja yang dapat direkomendasikan?

- Tentukan dulu output yang diinginkan
- Ada perhitungan berdasarkan kolom lain atau tidak? 
- Kalau ada : berdasarkan *rata-rata* views --> karena rata-rata maka perlu diagregasi

```{r}
# code here
vids_10 <- vids_clean %>% 
  filter(category_id == "Entertainment") %>% 
  group_by(channel_title) %>% 
  summarise(mean_viewers = mean(views)) %>% 
  ungroup() %>% 
  arrange(-mean_viewers) %>% 
  head(10)

vids_10
```

# ğŸ“ Summary DPLYR

Cocokan fungsi dplyr dan tahapan data wrangling yang dilakukan pada list di bawah:

* cek data: c. glimpse
* seleksi kolom: a. select
* filter baris: f. filter
* mengubah/membuat kolom: d. mutate
* agregasi data: b. group_by + summarise + ungroup
* mengurutkan data: e. arrange(desc())

Untuk memudahkan pengolahan, kita juga bisa menggunakan piping (%>%)

Referensi tambahan: [Official Documentation & Cheatsheet `dplyr`](https://dplyr.tidyverse.org/) 

- Pada dplyr, ktia dapat melakukan agregasi data menggunakan group_by dan summarise(), kemudian disempurnakan dengan fungsi penutup ungroup()
- group_by() digunakan untuk mengelompokkan berdasarkan kolom tertentu, sehingga proses apapun setelahnya dilakukan berdasarkan pengelompokkan tersebut.
- summarise() menghitung nilai statistik tertentu
- ungroup() melepaskan pengelompokkan agar proses apapun seteleahnya dilakukan untuk keseluruhan data.
- arrange() dapat digunakan untuk mengurutkan data

# Interactive Plot using `plotly`

```{r}
library(ggplot2) # pembuatan plot statis
library(plotly) # untuk plot interaktif
library(glue) # utk setting tooltip
library(scales)
```

**Plot interaktif membolehkan user untuk berinteraksi dengan plot** dan menghasilkan visualisasi yang lebih **ringkas, namun tetap informatif dan menarik**. Kita dapat menggunakan library `plotly` untuk membuat plot interaktif di R.

Link Official Plotly: https://plotly.com/r/

ğŸ“Š Tahapan pembuatan interactive plot dengan mudah menggunakan `plotly`:

   1. Business question
   2. Siapkan data
   3. Buat ggplot
   4. Ubah objek ggplot menjadi plotly

Sebelumnya kita telah menyiapkan 2 data hasil analisis (`vids_count` & `vids_10`). Mari visualisasikan 2 data tersebut menggunakan interactive plotting.

## ğŸ“‰ Plot 1: Trending Category 

**BQ:** Buatlah analisis mengenai kategori paling trending berdasarkan jumlah video yang masuk ke dalam jajaran video trending!

```{r}
# plot: ggplot2
plot1 <- ggplot(data = vids_count, aes(x = count, 
                              y = reorder(category_id, count))) + # reorder(A, berdasarkan B)
  geom_col(aes(fill = count)) +
  scale_fill_gradient(low="red", high="black") +
  labs(title = "Trending Categories of YouTube US 2017",
       x = "Video Count",
       y = NULL) +
  theme_minimal() +
  theme(legend.position = "none") 
plot1
```
ğŸ“Œ Note: 

- plot ranking: biasanya warna gradasi
- warna distinctive/berbeda warna tiap bar tidak direkomendasikan kalau category terlalu banyak 
- penghilangan legend bisa dilakukan karena redundansi informasi (informasi di legend sudah dijelaskan oleh x axis maupun nanti ketika di hover saat di plot interaktif)

**Diubah menjadi interaktif**

```{r}
# interactive plot
ggplotly(plot1, tooltip = "x")
```

### Tooltip

Untuk mempercantik plot interaktif, kita dapat menggunakan **tooltip**, yaitu informasi/label yang tertampilkan ketika user meng-hover plot. Kita dapat mempersiapkan informasi yang ingin ditampilkan pada kolom baru di data, kemudian meng-embed nya pada fungsi ggplotly.

Mengubah tooltip bisa menggunakan fungsi `glue()`

Intuisi penggunaan fungsi `glue()`

```{r}
makanan <- c(5000, 7000, 2000)
glue("Harga makanan: {makanan} rupiah")
```

```{r}
# menambahkan kolom berisi informasi tooltip
vids_count2 <- vids_count %>% 
  mutate(
    label = glue(
      "Category: {category_id}
      Video count: {count}"
    )
  )

vids_count2
```
Category: {category_id}
Video count: {count}

- Mengaplikasikan pada plot1

1. ubah data jadi vids_count2
2. tambahkan parameter `text = nama_kolom` didalam aes
3. buat ulang ggplotly
4. tambahkan parameter `tooltip = "text"`

```{r}
# buat ulang ggplot
plot1 <- ggplot(data = vids_count2, aes(x = count, 
                              y = reorder(category_id, count),# reorder(A, berdasarkan B)
                              text = label)) + # untuk informasi tooltip
  geom_col(aes(fill = count)) +
  scale_fill_gradient(low="red", high="black") +
  labs(title = "Trending Categories of YouTube US 2017",
       x = "Video Count",
       y = NULL) +
  theme_minimal() +
  theme(legend.position = "none") 
plot1
```

```{r}
# buat ulang plotly
ggplotly(plot1, tooltip = "text")
```

## ğŸ“‰ Plot 2: Trending Channel


**ğŸ„ DIVE DEEPER**

Selesaikan plot interaktif di bawah semenarik mungkin sesuai keinginan hatimu!

**BQ**: Dari kategori video yang kamu sukai, buatlah analisis mengenai Top 10 channel youtube dengan rata-rata jumlah viewers tertinggi!

```{r}
# data 
vids_10 <- vids_10 %>% 
  mutate(
    label = glue(
      "Channel: {channel_title}
      Average Views: {round(mean_viewers, 2)}"
    ) 
  )
```
tooltip

Channel: {namachannel}
Average Views: {123}

cara 1
```{r}
# ggplot: lolipop plot
plot2 <- ggplot(vids_10, aes(x = reorder(channel_title, mean_viewers), 
                    y = mean_viewers,
                    text = label)) +
  geom_segment(aes(x=reorder(channel_title, mean_viewers), xend=reorder(channel_title, mean_viewers), y=0,yend=mean_viewers), color="red") +
  geom_point(color="black") +
  coord_flip() +
  labs(title = "Top 10 Channel on Entertainment",
       x = NULL,
       y = "Average View") +
  theme_minimal()

plot2
```

cara 2: langsung pada parameter text
```{r}
# ggplot: lolipop plot
plot2 <- ggplot(vids_10, aes(x = reorder(channel_title, mean_viewers), 
                    y = round(mean_viewers, 2),
                    text = glue(
      "Channel: {channel_title}
      Average Views: {round(mean_viewers,2)}"
    ))) +
  geom_segment(aes(x=reorder(channel_title, mean_viewers), xend=reorder(channel_title, mean_viewers), y=0,yend=mean_viewers), color="red") +
  geom_point(color="black") +
  coord_flip() +
  labs(title = "Top 10 Channel on Entertainment",
       x = NULL,
       y = "Average View") +
  theme_minimal()

plot2
```

```{r}
# plotly
ggplotly(plot2, tooltip = "text")
```

## ğŸ“‰ Plot 3: Trending Activity

**BQ**: Setelah menganalisis tentang channel top 10 dari kategori video yang direkomendasikan, kita ingin melihat aktivitas viewers pada kategori tersebut di tiap `publish_hour`. Tipe plot apa yang baiknya digunakan? Buatkan interactive plotnya.

```{r}
# your code
vids_trend <- vids_clean %>% 
  filter(category_id == "Entertainment") %>% 
  group_by(publish_hour) %>% 
  summarise(avg_views = mean(views)) %>% 
  ungroup() %>% 
  mutate(label2 = glue(
    "Publish Hour: {publish_hour}
    Average Views: {comma(round(avg_views, 2))}"
  ))
vids_trend
```


```{r}
# plot
plot3 <- ggplot(vids_trend, aes(x=publish_hour, y= avg_views))+
  geom_line(col="red") +
  geom_point(aes(text=label2), col="black") +
  labs(
    title = "Viewers Activity of Entertainment Videos",
    x = "Publish Hours",
    y = "Average Views"
  ) +
  theme_minimal()
  
plot3  
  
```

```{r}
# buat plot menjadi interaktif dengan menambahkan tooltip
ggplotly(plot3, tooltip = "text")
```


- Plot statis
  + ggarrange()
  + ggexport()
- Plot interaktif
  + subplot
  + flexdashboard
  + shiny

# Exporting Plots with `ggpubr`

## `ggarrange()`

Untuk menyusun plot statis ke bentuk pdf.

```{r}
library(ggpubr)
publicat <- ggarrange(plot1, plot2, plot3, ncol=1)

# print hal 1
publicat
```

## `ggexport()`

Export visualisasi dalam ragam file extension. Berikut contoh untuk PDF:

```{r}
ggexport(publicat, filename="assets/publication_inclass.pdf")
```

Ke dalam extensi file lain (kebanyakan disimpan per plot nya saja): 

* https://r-coder.com/save-plot-r/
* https://www.datanovia.com/en/blog/how-to-save-a-ggplot/

## `subplot()`

```{r}
subplot(
  plot1,
  plot2, 
  plot3,
  nrows=2)
```

# ğŸ“ Summary

1. Tahapan Pembuatan plot Interaktif dari ggplot2:

- siapkan data: ditambahkan kolom untuk tooltip (info yang ingin ditampilkan ketika hover)

```
data <- data %>% 
 mutate(label = glue("isi tooltip"))
```

- buat ggplot, tambahkan aes text ke dalam codingan ggplot, assign ke objek

```
# umumnya di dalam geom
plot <- ggplot(data, aes(x = kolom_a, y = kolom_b, text = kolom_tooltip)) +
  geom_point() + dst...

# aes text bisa juga ditambahkan di geom, umumnya bila multiple geom
plot <- ggplot(data, aes(x = kolom_a, y = kolom_b)) +
  geom_point(aes(text = kolom_tooltip)) + dst ...
```

- buat plotly, atur tooltip agar menggunakan aes text.

```
ggplotly(plot, tooltip = "text")
```

2. Exporting plot:

- `ggarrange()`: menyusun plot statis
- `ggexport()`: mengexport plot yg sudah tersusun ke file PDF/dll.
- `subplot()`: menyusun plot interaktif

3. Untuk exporting plot interaktif (ataupun statis) bisa lebih banyak fiturnya bila menggunakan dashboard

---

# â“Inclass questions question

1. Pak Toni: cara subset berdasarkan index baris

  - Dapat menggunakan fungsi `slice()`, contoh kita melakukan slice pada baris 20 - 30
  
```{r}
vids %>% slice(20:30)
```

2. Bu Namira: kak untuk fungsi filter, bisa gak ya kita cari row dengan elemen tertentu? misalnya mau cari column Category_ID yang ada â€œandâ€ nya

  - Dapat menggunakan bantuan dari library `stringr`
  - [Dokumentasi](http://stringr.tidyverse.org/)
```{r}
?str_detect
```
 
  - [Cheatsheet](https://github.com/rstudio/cheatsheets/blob/main/strings.pdf)
```{r}
# akan mengembalikan nilai T/F
str_detect(vids$category_id, "and") %>% head(5)

# digabungkan dengan fungsi filter untuk mensubset pada data vids
filter(.data = vids, str_detect(vids$category_id, "and")) %>% head(5)
```

3. Pak Christoper: Grouping menggunakan `case_when` berdasarkan kondisi (ifelse)

Dokumentasi
```{r}
?case_when
```

```{r}
case_when(vids$publish_hour <= 12 ~ "Day",
          vids$publish_hour > 12 ~ "Night") %>% head(5)

# menerapkan pada data vids dan membuat kolom baru
vids %>% 
  mutate(dayornight = case_when(vids$publish_hour <= 12 ~ "Day",
          vids$publish_hour > 12 ~ "Night")) %>% head(5)
```

# ğŸ“Š Plot untuk Flexdashboard dan shiny

```{r}
library(tidyverse)
library(scales)
library(glue)
library(plotly)
library(lubridate)

vids <- read.csv("data_input/youtubetrends.csv", stringsAsFactors = T)

vids_clean <- vids %>% 
  # deselect kolom
  select(-c(comments_disabled, ratings_disabled, video_error_or_removed)) %>% 
  mutate(
    # mengubah tipe data
    trending_date = ymd(trending_date),
    publish_time = ymd_hms(publish_time),
    title = as.character(title),
    channel_title = as.character(channel_title),
    
    # menambahkan kolom baru
    likesp = likes/views,
    dislikep = dislikes/views,
    commentp = comment_count/views
  )

```

**Plot1: Trending Categories of YouTube US 2017**

```{r}
vids_count <- vids_clean %>% 
  group_by(category_id) %>% 
  summarise(count= n()) %>% 
  ungroup() %>% 
  arrange(-count)

vids_count2 <- vids_count %>% 
  mutate(
    label = glue(
      "Category: {category_id}
      Video count: {count}"
    )
  )

plot1 <- ggplot(data = vids_count2, aes(x = count, 
                              y = reorder(category_id, count),# reorder(A, berdasarkan B)
                              text = label)) + # untuk informasi tooltip
  geom_col(aes(fill = count)) +
  scale_fill_gradient(low="red", high="black") +
  labs(title = "Trending Categories of YouTube US 2017",
       x = "Video Count",
       y = NULL) +
  theme_minimal() +
  theme(legend.position = "none") 

ggplotly(plot1, tooltip = "text")

```

**Plot2: Top 10 Channel on Entertainment**

```{r}
vids_10 <- vids_clean %>% 
  filter(category_id == "Entertainment") %>% 
  group_by(channel_title) %>% 
  summarise(mean_viewers = mean(views)) %>% 
  ungroup() %>% 
  arrange(-mean_viewers) %>% 
  head(10)

vids_10 <- vids_10 %>% 
  mutate(
    label = glue(
      "Channel: {channel_title}
      Average Views: {comma(round(mean_viewers, 2))}"
    ) 
  )

plot2 <- ggplot(vids_10, aes(x = reorder(channel_title, mean_viewers), 
                    y = mean_viewers,
                    text = label)) +
  geom_segment(aes(x=reorder(channel_title, mean_viewers), xend=reorder(channel_title, mean_viewers), y=0,yend=mean_viewers), color="red") +
  geom_point(color="black") +
  coord_flip() +
  labs(title = "Top 10 Channel on Entertainment",
       x = NULL,
       y = "Average View") +
  scale_y_continuous(labels = comma) +
  theme_minimal()

ggplotly(plot2, tooltip = "text")
```

**Plot 3: Viewers Activity of Entertainment Videos**

```{r}
vids_trend <- vids_clean %>% 
  filter(category_id == "Entertainment") %>% 
  group_by(publish_hour) %>% 
  summarise(avg_views = mean(views)) %>% 
  ungroup() %>% 
  mutate(label2 = glue(
    "Publish Hour: {publish_hour}
    Average Views: {comma(round(avg_views, 2))}"
  ))

plot3 <- ggplot(vids_trend, aes(x=publish_hour, y= avg_views))+
  geom_line(col="red") +
  geom_point(aes(text=label2), col="black") +
  labs(
    title = "Viewers Activity of Entertainment Videos",
    x = "Publish Hours",
    y = "Average Views"
  ) +
  scale_y_continuous(labels = comma) +
  scale_x_continuous(breaks = seq(0,23,1)) +
  theme_minimal()

ggplotly(plot3, tooltip = "text")
```


